Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-01-22T19:15:29+03:00

====== Resolve IP адресов в Linux ======
Создан Среда 22 января 2020

см.:
[[https://habr.com/ru/post/352300/|Resolve IP адресов в Linux]]
[[https://zalinux.ru/?p=2814|Как в Linux определяется порядок источников для разрешения имён]]

У операционной системы Linux есть несколько источников для определения адреса по hostname. Весь необходимый функционал для определения находится в GNU C Library (glibc). glibc является по-сути фреймворком и реализовывает множество полезных функций для разработчика, предоставляя свой API для упрощения разработки. Среди прочего, glibc имплементирует POSIX. Такие функции как ''open, read, write, malloc, printf, getaddrinfo, dlopen, pthread_create, crypt, login, exit'' для Linux систем предоставляет именно glibc.

Известные многим утилиты ''host, dig и nslookup'' используют glibc, но поставляются отдельно.

Теперь, когда у разработчика есть возможность вызвать функцию семейства getaddrinfo из glibc для определения адреса, то возникает потребность конфигурировать возвращаемые значения. Например, использовать ли сперва /etc/hosts или запрос к DNS-серверу. В glibc подобное конфигурирование производится с помощью схемы под названием Name Service Switch (NSS).

Если объяснять на пальцах, то NSS позволяет задавать базы данных и очередность поиска в этих базах для предоставления сервиса. В нашем случае, сервис — это поиск по hostname, а базой данных может выступать /etc/hosts или DNS сервер. Это не единственный сервис настраиваемый посредством NSS, предоставляются сервисы mail алиасов, сервис поиска пользователей и групп. Ознакомится со списком можно в руководстве.

Благодаря NSS можно без пересборки приложений, в рантайме, конфигурировать упомянутые базы данных. Производится конфигурирование в файле /etc/nsswitch.conf. Ниже пример конфига из стандартного /etc/nsswitch.conf в Centos 7.

{{{code: lang="sh" linenumbers="False"
$ grep ^hosts /etc/nsswitch.conf
}}}

	''hosts:      files dns myhostname''

**files**, **dns** и **myhostname** являются алиасами баз данных для поиска. **files** на большинстве систем подразумевает использование ''/etc/hosts'', **dns** база — это DNS-сервер к которому будет осуществляться запрос поиска hostname, а **myhostname** — это самая необычная база, о существовании которой мало кто знает и она не является частью стандартной поставки в glibc. В некоторых дистрибутивах присутствует еще и база **mdns4_minimal**. Ниже по тексту предоставлен разбор этих баз данных.

Базы используются в том порядке в котором они обьявлены в ''/etc/nsswitch.conf'' и если в текущей базе запись найдена, то происходит выход из цепочки и возврат результата. При отсутствии результата происходит переход к следующей базе в списке. Если ни в одной базе не найден результат, то такой ответ и дается на запрос glibc функции getaddrinfo. Поведение перехода к следующей базе и условия такого перехода можно дополнительно конфигурировать, например, при недоступности DNS (не путать с отсутствием записи) завершить цепочку. Понятное и простое объяснение принципа настройки условий для ''/etc/nsswitch.conf'' даны в этой статье.

База **files**, а в частности ''/etc/hosts'', из коробки в Centos 7 выглядит следующим образом:

{{{code: lang="sh" linenumbers="False"
$ cat /etc/hosts
}}}

'''
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
'''


Можно отметить, что для ''localhost'' имеются две записи: IPv4 и IPv6 адрес. Это может сыграть злую шутку и в конце материала я расскажу почему.

База dns при определении адреса использует name server указанный в конфиге ''/etc/resolv.conf''. Вот пример моего ''/etc/resolv.conf'' на хост системе:

{{{code: lang="sh" linenumbers="False"
$ cat /etc/resolv.conf
}}}

'''
# Generated by NetworkManager
nameserver 127.0.0.1
nameserver 192.168.100.1
'''


Name server'а используются тоже по цепочке и в порядке их объявления. В моем случае, первым выступает локальный DNS сервер (я использую dnsmasq) для задания локальных адресов .priv зон. Если находится совпадение, то возвращается адрес из локальной сети. Все остальные запросы отправляются на основной DNS сервер с адресом 192.168.100.1.

База myhostname присутствует в поставке Centos и Ubuntu, но не является частью glibc. Не зная этого факта я потратил много времени пытаясь выяснить почему мне возвращаются IPv6 адреса для определения хоста. Он работает следующим образом:

* при запросе локального хостнейма (того что возвращает команда hostname) плагин возвращает все IP адреса публичных интерфейсов (т.е. все кроме loopback), при отсутствии таких интерфейсов возвращается IPv4 адрес 127.0.0.2 и IPv6 адрес ::1;
* при запросе хостнейма localhost или localhost.localdomain возвращает IPv4 адрес 127.0.0.1 и IPv6 адрес ::1;
* при запросе хостнейма оканчивающегося на .localhost или .localhost.localdomain возвращает IPv4 адрес 127.0.0.1 и IPv6 адрес ::1;

База **mdns4_minimal** или же **mdns_minimal** требуется для корректной работы Avahi. При необходимости можно обратиться к [[https://wiki.archlinux.org/index.php/avahi|документации Arch по Avahi]], где коротко и понятно дана информация по использованию.

Теперь, когда дана информация по базам и принципам их работы стоит отметить отличия в определении адресов в разных инструментах, что приводит к проблемам в рантайме.

Обычно администраторы проверяют хостнейм используя команду host. Это некорректно, так host, как и dig, используют только DNS резолвинг, но не используют NSS. Nginx, например, использует функцию getaddrinfo, а она использует NSS. Это приводит к тому, что вбитый в /etc/hosts хостнейм может работать с nginx, но не резолвится иными способами. Куда хуже, когда в /etc/hosts вбиты IPv6 адрес для хостнейма, а в настройках DNS возвращается только IPv4 адрес. В этом случае, администратор может проверить что команда host возвращает только IPv4 адрес и успокоится, а потом приложение использующее getaddrinfo из glibc запустится и найдет для того же хостнейма IPv4 и IPv6 адрес. Источник ошибок…

Для проверки результатов возвращаемой каждой из баз документация рекомендует воспользоваться утилитой getent.

Ниже немного примеров работы с getent с включенным IPv6.

В /etc/nsswitch.conf содержится следующая цепочка баз:

	''hosts:      files dns myhostname''

В /etc/hosts содержится следующее инфо

{{{code: lang="sh" linenumbers="False"
$ cat /etc/hosts
}}}

'''
127.0.0.1    localhost
::1          localhost ip6-localhost ip6-loopback
'''


Команда getent ahosts <hostname> покажет список всех адресов которые удалось найти. С такими настройками она выведет следующее:

{{{code: lang="sh" linenumbers="False"
$ getent ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


Команда позволяет точечно опросить конкретную базу и выяснить что срезолвит база. Рассмотрим для каждой базы возвращаемые значения:

{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:files ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:dns ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:myhostname ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


Если убрать из /etc/hosts строки для localhost, то вывод видоизменится:

{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:files ahosts localhost
}}}


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:dns ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:myhostname ahosts localhost
}}}

'''
::1             STREAM localhost
::1             DGRAM
::1             RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


Теперь база dns и myhostname возвращает ответы, а база files не содержит данных. Для DNS запросов используется неймсервер конфигурируемый в /etc/resolv.conf в моем контейнере, например

{{{code: lang="sh" linenumbers="False"
$ cat /etc/resolv.conf
}}}

'''
nameserver 127.0.0.11
options ndots:0
'''


На хост машине установлен dnsmasq который проксирует и кэширует ответы DNS серверов. Ответ от DNS будет зависеть от настроек DNS сервера к которому поступил запрос. RFC 1912 рекомендует в пункте 4.1 сконфигурировать DNS сервера таким образом, чтобы localhost указывал на 127.0.0.1.

	Certain zones should always be present in nameserver configurations:

'''
primary         localhost               localhost
primary         0.0.127.in-addr.arpa    127.0
primary         255.in-addr.arpa        255
primary         0.in-addr.arpa          0
'''


	These are set up to either provide nameservice for "special"
	addresses, or to help eliminate accidental queries for broadcast or
	local address to be sent off to the root nameservers. All of these
	files will contain NS and SOA records just like the other zone files
	you maintain, the exception being that you can probably make the SOA
	timers very long, since this data will never change.

	The "localhost" address is a "special" address which always refers to
	the local host. It should contain the following line:

	''localhost.      IN      A       127.0.0.1''

В моем случае, dnsmasq из коробки содержит записи для localhost, как и рекомендует RFC.

{{{code: lang="sh" linenumbers="False"
$ dig +noall +answer localhost ANY @127.0.0.1
}}}

'''
localhost.      0   IN  A       127.0.0.1
localhost.      0   IN  AAAA    ::1
'''


Отключается это либо удалением записей из /etc/hosts на самом DNS сервере, либо же включением опции no-hosts в /etc/dnsmasq.conf.

После включения опции getent для базы myhostname вернет непустой результат, но как и отмечалось выше, с включенным myhostname будет возвращаться IPv4 и IPv6 адрес. На системах со статическими IP адресами можно смело выключить myhostname плагин и конфигурировать локальные хосты с использованием /etc/hosts. Альтернативный вариант — это отключение IPv6.

Статус IPv6 на сервере можно получить из параметров ядра. Значение 0 возвращается при включенном IPv6, а 1 при выключенном.

{{{code: lang="sh" linenumbers="False"
$ sysctl net.ipv6.conf.all.disable_ipv6 net.ipv6.conf.default.disable_ipv6
}}}

'''
net.ipv6.conf.all.disable_ipv6 = 0
net.ipv6.conf.default.disable_ipv6 = 0
'''


В выводе ifconfig интерфейсы слушающие IPv6 содержат строчку inet6. Ниже пример вывода с выключенным и включенным IPv6 соответственно:

# disabled
{{{code: lang="sh" linenumbers="False"
$ ifconfig -a
}}}

'''
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.101.5  netmask 255.255.255.0  broadcast 0.0.0.0
        ether 02:42:c0:a8:65:05  txqueuelen 0  (Ethernet)
        RX packets 15789549  bytes 2553533549 (2.3 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9783999  bytes 1318627420 (1.2 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1  (Local Loopback)
        RX packets 606047  bytes 67810892 (64.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 606047  bytes 67810892 (64.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
'''


# enabled
{{{code: lang="sh" linenumbers="False"
$ ifconfig -a
}}}

'''
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.101.5  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::42:c0ff:fea8:6505  prefixlen 64  scopeid 0x20<link>
        ether 02:42:c0:a8:65:05  txqueuelen 0  (Ethernet)
        RX packets 15787641  bytes 2553216408 (2.3 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9782965  bytes 1318487919 (1.2 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1  (Local Loopback)
        RX packets 605949  bytes 67799887 (64.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 605949  bytes 67799887 (64.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
'''


Выключить IPv6 можно вызовом

{{{code: lang="sh" linenumbers="False"
$ sysctl -w net.ipv6.conf.all.disable_ipv6=1
$ sysctl -w net.ipv6.conf.default.disable_ipv6=1
}}}


Что изменится после выключения? Я откатил все конфиги на стандартные: в /etc/hosts присутствует localhost с адресами IPv4 и IPv6, в dnsmasq выключена опция no-hosts. Отключил IPv6 командами выше и вывод getent стал следующим:

{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:files ahosts localhost
}}}

'''
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM
127.0.0.1       RAW
127.0.0.1       STREAM
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:dns ahosts localhost
}}}

'''
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM
127.0.0.1       RAW
'''


{{{code: lang="sh" linenumbers="False"
$ getent -s hosts:myhostname ahosts localhost
}}}

'''
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM
127.0.0.1       RAW
'''



